/**
 * Package:	Online update
 * Summary:	Selection dialog
 * Authors:	Cornelius Schumacher <cschum@suse.de>
 *
 * Call the PackageSelector in YOU mode.
 */
{

  textdomain "online-update";

  import "Directory";
  import "FileUtils";
  import "Label";
  import "OnlineUpdate";
  import "Popup";
  import "ProductFeatures";
  import "Wizard";

  if (OnlineUpdate::cd_update)
  {
    boolean canceled	= false;
    do
    {
	string initMessage = _("Initializing for CD update...");
	UI::OpenDialog(`opt(`decorated ),`Label( initMessage ));
	OnlineUpdate::cd_source = Pkg::SourceCreate (
	    OnlineUpdate::cd_url, OnlineUpdate::cd_directory);
	UI::CloseDialog();

	if (OnlineUpdate::cd_source == -1)
	{
	    canceled = !Popup::AnyQuestion ("",
		// error popup: cancel/retry buttons follow
		_("Initialization failed. Check that
you have inserted the correct CD.
"),
		Label::RetryButton (), Label::CancelButton (), `focus_yes);
	}
    } while (OnlineUpdate::cd_source == -1 && !canceled);

    if (canceled)
	return `abort;
  }


  Pkg::PkgEstablish();

  boolean restart_yast	= false;
  boolean reboot_needed	= false;
  boolean relogin_needed= false;
  boolean normal_patches_selected	= false;
  integer selected	= 0;
  string saved_path	= Directory::vardir + "/selected_patches.ycp";
  list<string> reboot_packages	= [];

  // check if YaST was restarted
  if (FileUtils::Exists (saved_path))
  {
    string saved	= (string) SCR::Read (.target.ycp, saved_path);
    // before restart, patch requiring reboot was installed:
    // show the reboot popup now
    if (saved != nil && is (saved, string) && saved == "reboot")
	reboot_needed	= true;
    SCR::Execute (.target.remove, saved_path);
  }

  Pkg::PkgApplReset (); // ensure there are no transactions set accidentally
  map<string,any> solver_flags_backup	= Pkg::GetSolverFlags ();
  // ignore reccomends when we weant only pkg management patches
  Pkg::SetSolverFlags ($[
	"ignoreAlreadyRecommended"	: true,
	"onlyRequires"			: true
  ]);
  Pkg::PkgSolve (true);

  // 1st, select the patches affecting pkg management
  selected = Pkg::ResolvablePreselectPatches (`affects_pkg_manager);
  y2milestone ("Preselected patches for pkg management: %1", selected);

  // if no patch is selected, pre-select all security and recommended
  if (selected < 1)
  {
    // restore the original solver settings - enable recommends
    Pkg::SetSolverFlags (solver_flags_backup);
    // new solver run required to include recommends
    Pkg::PkgSolve (true);

    selected = Pkg::ResolvablePreselectPatches (`all);
    y2milestone ("All preselected patches: %1", selected);
  }

  Wizard::ClearContents();// do not show the remnant of initial progress

  boolean display_support_status = ProductFeatures::GetBooleanFeature
    ("software", "display_support_status");
  term widget_options = `opt (`youMode);
  if (display_support_status == true)
  {
      widget_options	= add (widget_options, `confirmUnsupported);
  }
  widget_options = add(widget_options, `repoMgr);

  boolean simple_mode = OnlineUpdate::simple_mode && (UI::HasSpecialWidget(`SimplePatchSelector) == true);
  if (simple_mode)
  {
    UI::OpenDialog (`opt(`defaultsize), `SimplePatchSelector(`id(`selector)));
  }
  else
    UI::OpenDialog (`opt(`defaultsize), `PackageSelector(`id(`selector), widget_options));

  symbol ret		= nil;
  string current	= "simple";
  repeat
  {
    ret = (symbol) UI::RunPkgSelection (`id(`selector));
    y2milestone ("RunPkgSelection returned %1", ret);
    UI::CloseDialog();
    if (ret == `details)
    {
	UI::OpenDialog (`opt(`defaultsize), `PackageSelector(`id(`selector), widget_options));
	current	= "rich";
    }
    if (ret == `cancel && simple_mode && current == "rich")
    {
	UI::OpenDialog (`opt(`defaultsize), `SimplePatchSelector(`id(`selector)));
	current	= "simple";
	ret	= nil;
    }
    if (ret == `online_update_configuration || ret == `repo_mgr)
    {
	any result	= nil;
	if (ret == `online_update_configuration)
	    result	= WFM::CallFunction ("online_update_configuration", []);
	else
	    result	= WFM::CallFunction ("repositories", [`sw_single_mode]);

	if (result == `next || result == `finish)
	{
	    Pkg::SetSolverFlags ($[
		"ignoreAlreadyRecommended"	: true,
		"onlyRequires"			: true
	    ]);
	    Pkg::PkgSolve (true);
	    // select the patches affecting pkg management
	    selected = Pkg::ResolvablePreselectPatches (`affects_pkg_manager);
	    y2milestone ("patches for pkg management: %1", selected);
	    if (selected < 1)
	    {
		Pkg::SetSolverFlags (solver_flags_backup);
		Pkg::PkgSolve (true);
		selected = Pkg::ResolvablePreselectPatches (`all);
		y2milestone ("preselected patches: %1", selected);
	    }
	}
	// open the dialog with patch view again
	UI::OpenDialog (`opt(`defaultsize),
	    `PackageSelector(`id(`selector), widget_options));
    }
    if (ret == `accept)
    {
	restart_yast		= false;
	normal_patches_selected	= false;
	foreach (map patch, Pkg::ResolvableProperties ("", `patch, ""), {
	    if (patch["status"]:`none == `selected)
	    {
		if (patch["affects_pkg_manager"]:false)
		    restart_yast		= true;
		else
		    normal_patches_selected	= true;
	    }
	});
	if (restart_yast && normal_patches_selected)
	{
	    if (!Popup::ContinueCancel (OnlineUpdate::more_selected_message))
	    {
		ret	= nil;
		UI::OpenDialog (`opt(`defaultsize), `PackageSelector(`id(`selector), widget_options));
	    }
	}
    }
  } until ( ret == `cancel || ret == `accept );

  Wizard::ClearContents();

  y2milestone ("RunPkgSelection finally returned '%1'", ret);

  // restore the original solver settings, just to be sure...
  Pkg::SetSolverFlags (solver_flags_backup);

  if ( ret == `cancel ) return `abort;

  boolean more_patches_needed		= false;
  foreach (map patch, Pkg::ResolvableProperties("", `patch, ""), {
    if (patch["status"]:`none == `selected)
    {
	y2milestone ("selected patch: %1", patch);

        // check if release notes package was selected for update
        // if so, user should see new release notes (fate#314072)
        foreach (string name, string version, patch["contents"]:$[], {
            if (!OnlineUpdate::show_release_notes && issubstring (name, "release-notes"))
            {
                foreach (map package, Pkg::ResolvableProperties (name, `package, ""), {
                  if (package["status"]:`none == `selected)
                  {
                    OnlineUpdate::show_release_notes        = true;
                    y2milestone ("release notes package '%1' (%2) selected for installation", name, version);
                  }
                });
            }
        });

	if (patch["reboot_needed"]:false)
	{
	    reboot_needed	= true;
	    reboot_packages	= (list<string>) union (
		reboot_packages, [ patch["name"]:"" ]);
	}
	if (patch["relogin_needed"]:false)
	    relogin_needed	= true;
	if (patch["affects_pkg_manager"]:false)
	    restart_yast	= true;
        else
	    normal_patches_selected	= true;
    }
    // patch not selected: bug #188541 - touch saved_path to force the restart
    else if (patch["is_needed"]:false)
    {
	y2milestone ("patch needed but not selected: %1", patch);
	more_patches_needed	= true;
    }
  });

  // tell the caller (/sbin/yast2) to call online update again
  if (restart_yast && more_patches_needed)
  {
    // what if kernel (=reboot) and zypp (=restart) are installed together?
    // => restart YaST and show reboot message after the second run
    string save_message	= "restart";
    if (reboot_needed)
	save_message	= "reboot";
    SCR::Write (.target.ycp, saved_path, save_message);
    // show reboot popup only when yast is not going to restart now
    reboot_needed	= false;
  }
  else if (restart_yast)
  {
      y2debug ("nothing left for the second run, no restart needed");
  }

  // no patch selected
  if (!restart_yast && !normal_patches_selected &&
      !Pkg::PkgAnyToInstall () && !Pkg::PkgAnyToDelete ())
  {
      ret = `cancel;
  }
  OnlineUpdate::restart_yast	= restart_yast;
  OnlineUpdate::reboot_needed	= reboot_needed;
  OnlineUpdate::reboot_packages	= reboot_packages;
  OnlineUpdate::relogin_needed	= relogin_needed;

  if ( ret == `cancel ) return `abort;
  else return `next;
}
